A mini lisp written by C

* error in book
** chapter 9
function builtin_op
   if (y->num == 0) {
        lval_del(x); lval_del(y); 
        lval_del(a);//cannot delete a here.
        x = lval_err("Division By Zero!"); break;
      } else {
        x->num /= y->num;
      }
** chapter 12
function lval_copy
#+begin_src C
case LVAL_FUN:
        if(v->builtin){
            x->builtin = v->builtin; 
        }else {
            x->builtin = v->builtin; //here, we should make sure x->builtin is initialize to 0, otherwise it could be any value so I add this line.
            x->env = lenv_copy(v->env);
            x->formals = lval_copy(v->formals);
            x->body = lval_copy(v->body);
        }
        break;
#+end_src

* questions
- test case =+ 2 (head {2 4})= cannot eval correctly, because head
  return a qexpr, which is not number, and not able to caculate. May
  resolve it later. If my lisp is a dynamic language, its OK. I am not
  sure if my lisp will be a dynamic language. Edit: I can do it this
  way =+ 2 (eval (head {2 4}))=, this could be right.   
- We need to prevent user to def the builtin symbols, like =head=,
  user can redefine it like =def {head} 1=, then we will lose this
  builtin function. 
- 'exit' function, to implement it. We let func envoke even only no
  argument is needed.
